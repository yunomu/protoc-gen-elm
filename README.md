# protoc-gen-elm

`protoc-gen-elm` is a plugin for the Google Protocol Buffers compiler (`protoc`) that generates Elm types, JSON decoders, and JSON encoders from your `.proto` files.

This allows you to maintain a single source of truth for your data structures in `.proto` files and automatically generate the corresponding Elm code, ensuring your frontend and backend data models stay in sync.

## Features

-   **Elm Type Generation**: Generates Elm `type alias` for each Protobuf message.
-   **JSON Decoders**: Creates a `Json.Decode` based decoder for each message, ensuring robust JSON parsing.
-   **JSON Encoders**: Creates a `Json.Encode.object` based encoder for each message.
-   **Naming Convention**: Converts Protobuf's `snake_case` field names to Elm's `camelCase` convention.
-   **Repeated Fields**: Handles `repeated` fields by converting them to `List` types in Elm.
-   **Bytes Fields**: Handles `bytes` fields by converting them to `Bytes.Bytes` in Elm, with Base64 encoding/decoding for JSON.
-   **File/Directory Naming**: Generates directory and file names in `UpperCamelCase` based on the proto package and filename.
-   **Header Comment**: Adds a "do not edit" comment to the top of each generated file, indicating that it is auto-generated.

## Prerequisites

Before using this tool, you need to have the following installed:

-   [Go](https://go.dev/doc/install)
-   [Protocol Buffer Compiler (`protoc`)](https://grpc.io/docs/protoc-installation/)

## Installation

You can install the plugin using `go get`:

```shell
go get github.com/yunomu/protoc-gen-elm
```

Alternatively, you can build it from the source:

```shell
git clone https://github.com/yunomu/protoc-gen-elm.git
cd protoc-gen-elm
go build -o protoc-gen-elm .
```

## Usage

To generate Elm code from a `.proto` file, run the `protoc` command with the `protoc-gen-elm` plugin.

The basic command structure is as follows:

```shell
protoc --plugin=protoc-gen-elm --elm_out=<OUTPUT_DIRECTORY> <YOUR_PROTO_FILE>.proto
```

-   `--plugin=protoc-gen-elm`: Specifies the name of the plugin executable. If you installed it via `go get`, it should be in your `GOPATH/bin`.
-   `--elm_out=<OUTPUT_DIRECTORY>`: Specifies the directory where the generated Elm files should be placed.

### Example

Given a file named `testdata/test.proto`:

```protobuf
syntax = "proto3";

package test;

option go_package = "./test";

message User {
  string user_id = 1;
  string user_name = 2;
  int32 age = 3;
  bytes blob = 4;
}

message UserList {
  repeated User users = 1;
}
```

To generate the Elm code for this file, run the following command:

```shell
protoc --plugin=protoc-gen-elm --elm_out=. testdata/test.proto
```

This will generate a new file at `Test.elm`:

```elm
-- DO NOT EDIT
--
-- This file is automatically generated by protoc-gen-elm.
-- Source: test.proto

module Test exposing
    ( User
    , UserList
    , userDecoder
    , userEncoder
    , userListDecoder
    , userListEncoder
    )

import Base64.Decode as BDecode
import Base64.Encode as BEncode
import Bytes
import Json.Decode as Decode
import Json.Encode as Encode


base64error : BDecode.Error -> Decode.Decoder a
base64error err =
    case err of
        BDecode.ValidationError ->
            Decode.fail "base64 validation error"

        BDecode.InvalidByteSequence ->
            Decode.fail "base64 invalid byte sequence"


result : (error -> a) -> (value -> a) -> Result error value -> a
result errf f r =
    case r of
        Ok v ->
            f v

        Err err ->
            errf err


decodeBytes : Decode.Decoder Bytes.Bytes
decodeBytes =
    Decode.string
        |> Decode.andThen
            (BDecode.decode BDecode.bytes >> result base64error Decode.succeed)


encodeBytes : Bytes.Bytes -> Encode.Value
encodeBytes =
    Encode.string << BEncode.encode << BEncode.bytes


type alias User =
    { userId : String
    , userName : String
    , age : Int
    , blob : Bytes.Bytes
    }


userDecoder : Decode.Decoder User
userDecoder =
    Decode.map4 User
        (Decode.field "userId" Decode.string)
        (Decode.field "userName" Decode.string)
        (Decode.field "age" Decode.int)
        (Decode.field "blob" decodeBytes)


userEncoder : User -> Encode.Value
userEncoder user =
    Encode.object
        [ ("userId", Encode.string user.userId)
        , ("userName", Encode.string user.userName)
        , ("age", Encode.int user.age)
        , ("blob", encodeBytes user.blob)
        ]


type alias UserList =
    { users : (List User)
    }


userListDecoder : Decode.Decoder UserList
userListDecoder =
    Decode.map UserList
        (Decode.field "users" (Decode.list userDecoder))


userListEncoder : UserList -> Encode.Value
userListEncoder userList =
    Encode.object
        [ ("users", (Encode.list userEncoder userList.users))
        ]
```
