package main

import (
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// camelCase converts a snake_case string to camelCase.
func camelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := 1; i < len(parts); i++ {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

// upperCamelCase converts a snake_case string to UpperCamelCase.
func upperCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	pathParts := strings.Split(file.GeneratedFilenamePrefix, "/")
	for i, part := range pathParts {
		pathParts[i] = upperCamelCase(part)
	}
	filename := strings.Join(pathParts, "/") + ".elm"

	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("-- DO NOT EDIT")
	g.P("--")
	g.P("-- This file is automatically generated by protoc-gen-elm.")
	g.P("-- Source: ", file.Desc.Path())
	g.P("")

	moduleName := strings.ReplaceAll(filename, "/", ".")
	moduleName = strings.TrimSuffix(moduleName, ".elm")

	g.P("module ", moduleName, " exposing (..)")
	g.P("")
	g.P("import Json.Decode as Decode")
	g.P("import Json.Decode.Pipeline as Pipeline")
	g.P("import Json.Encode as Encode")
	g.P("")

	for _, msg := range file.Messages {
		genMessage(g, msg)
		genDecoder(g, msg)
		genEncoder(g, msg)
	}

	return g
}

func genMessage(g *protogen.GeneratedFile, msg *protogen.Message) {
	messageName := msg.GoIdent.GoName
	g.P("type alias ", messageName, " =")
	g.P("    { ")

	for i, field := range msg.Fields {
		fieldName := camelCase(string(field.Desc.Name()))
		fieldType := elmType(field)

		separator := ","
		if i == len(msg.Fields)-1 {
			separator = ""
		}
		g.P("    ", fieldName, " : ", fieldType, separator)
	}
	g.P("    }")
	g.P("")
}

func genDecoder(g *protogen.GeneratedFile, msg *protogen.Message) {
	messageName := msg.GoIdent.GoName
	decoderName := strings.ToLower(messageName[:1]) + messageName[1:] + "Decoder"

	g.P(decoderName, " : Decode.Decoder ", messageName)
	g.P(decoderName, " =")
	g.P("    Pipeline.decode ", messageName)

	for _, field := range msg.Fields {
		jsonName := field.Desc.JSONName()
		fieldDecoder := elmDecoder(field)
		g.P("        |> Pipeline.required \"", jsonName, "\" ", fieldDecoder)
	}
	g.P("")
}

func genEncoder(g *protogen.GeneratedFile, msg *protogen.Message) {
	messageName := msg.GoIdent.GoName
	encoderName := strings.ToLower(messageName[:1]) + messageName[1:] + "Encoder"
	instanceName := strings.ToLower(messageName[:1]) + messageName[1:]

	g.P(encoderName, " : ", messageName, " -> Encode.Value")
	g.P(encoderName, " ", instanceName, " =")
	g.P("    Encode.object")
	g.P("        [ ")

	for i, field := range msg.Fields {
		fieldName := camelCase(string(field.Desc.Name()))
		jsonName := field.Desc.JSONName()
		fieldEncoder := elmEncoder(field, instanceName+"."+fieldName)

		separator := ","
		if i == len(msg.Fields)-1 {
			separator = ""
		}
		g.P("            (\"", jsonName, "\", ", fieldEncoder, ")", separator)
	}

	g.P("        ]")
	g.P("")
}

func elmType(field *protogen.Field) string {
	var t string
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		t = "String"
	case protoreflect.Int32Kind, protoreflect.Int64Kind, protoreflect.Sint32Kind, protoreflect.Sint64Kind, protoreflect.Uint32Kind, protoreflect.Uint64Kind, protoreflect.Fixed32Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed32Kind, protoreflect.Sfixed64Kind:
		t = "Int"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		t = "Float"
	case protoreflect.BoolKind:
		t = "Bool"
	case protoreflect.MessageKind:
		t = field.Message.GoIdent.GoName
	default:
		t = "-- unknown type"
	}

	if field.Desc.IsList() {
		return "(List " + t + ")"
	}
	return t
}

func elmDecoder(field *protogen.Field) string {
	var d string
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		d = "Decode.string"
	case protoreflect.Int32Kind, protoreflect.Int64Kind, protoreflect.Sint32Kind, protoreflect.Sint64Kind, protoreflect.Uint32Kind, protoreflect.Uint64Kind, protoreflect.Fixed32Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed32Kind, protoreflect.Sfixed64Kind:
		d = "Decode.int"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		d = "Decode.float"
	case protoreflect.BoolKind:
		d = "Decode.bool"
	case protoreflect.MessageKind:
		messageName := field.Message.GoIdent.GoName
		d = strings.ToLower(messageName[:1]) + messageName[1:] + "Decoder"
	default:
		return "-- unknown decoder"
	}

	if field.Desc.IsList() {
		return "(Decode.list " + d + ")"
	}
	return d
}

func elmEncoder(field *protogen.Field, fieldAccessor string) string {
	var e string
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		e = "Encode.string"
	case protoreflect.Int32Kind, protoreflect.Int64Kind, protoreflect.Sint32Kind, protoreflect.Sint64Kind, protoreflect.Uint32Kind, protoreflect.Uint64Kind, protoreflect.Fixed32Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed32Kind, protoreflect.Sfixed64Kind:
		e = "Encode.int"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		e = "Encode.float"
	case protoreflect.BoolKind:
		e = "Encode.bool"
	case protoreflect.MessageKind:
		messageName := field.Message.GoIdent.GoName
		e = strings.ToLower(messageName[:1]) + messageName[1:] + "Encoder"
	default:
		return "-- unknown encoder"
	}

	if field.Desc.IsList() {
		// The encoder function for the inner type doesn't take an argument, so we need to handle it slightly differently.
		encoderName := e
		if !strings.HasSuffix(e, "Encoder") {
			// For primitive types, the function name is just the type (e.g., Encode.string)
			// For message types, it's the function name we constructed (e.g., userEncoder)
			encoderName = e
		}
		return "(Encode.list " + encoderName + " " + fieldAccessor + ")"
	}
	return e + " " + fieldAccessor
}
