package generator

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type Generator struct {
	gen *protogen.Plugin
}

func New(gen *protogen.Plugin) *Generator {
	return &Generator{gen: gen}
}

// camelCase converts a snake_case string to camelCase.
func camelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := 1; i < len(parts); i++ {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

// upperCamelCase converts a snake_case string to UpperCamelCase.
func upperCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

func (g *Generator) GenerateFile(file *protogen.File) *protogen.GeneratedFile {
	protoPath := file.Desc.Path()
	path := strings.TrimSuffix(protoPath, ".proto")

	pathParts := strings.Split(path, "/")
	for i, part := range pathParts {
		pathParts[i] = upperCamelCase(part)
	}
	filename := strings.Join(pathParts, "/") + ".elm"

	f := g.gen.NewGeneratedFile(filename, file.GoImportPath)

	f.P("-- DO NOT EDIT")
	f.P("--")
	f.P("-- This file is automatically generated by protoc-gen-elm.")
	f.P("-- Source: ", file.Desc.Path())
	f.P("")

	moduleName := strings.ReplaceAll(filename, "/", ".")
	moduleName = strings.TrimSuffix(moduleName, ".elm")

	f.P("module ", moduleName, " exposing (..)")
	f.P("")
	f.P("import Json.Decode as Decode")
	f.P("import Json.Decode.Pipeline as Pipeline")
	f.P("import Json.Encode as Encode")
	f.P("")

	for _, msg := range file.Messages {
		g.genMessage(f, msg)
		g.genDecoder(f, msg)
		g.genEncoder(f, msg)
	}

	return f
}

func (g *Generator) genMessage(f *protogen.GeneratedFile, msg *protogen.Message) {
	messageName := msg.GoIdent.GoName
	f.P("type alias ", messageName, " =")
	f.P("    { ")

	for i, field := range msg.Fields {
		fieldName := camelCase(string(field.Desc.Name()))
		fieldType, err := elmType(field)
		if err != nil {
			g.gen.Error(err)
			return
		}

		separator := ","
		if i == len(msg.Fields)-1 {
			separator = ""
		}
		f.P("    ", fieldName, " : ", fieldType, separator)
	}
	f.P("    }")
	f.P("")
}

func (g *Generator) genDecoder(f *protogen.GeneratedFile, msg *protogen.Message) {
	messageName := msg.GoIdent.GoName
	decoderName := strings.ToLower(messageName[:1]) + messageName[1:] + "Decoder"

	f.P(decoderName, " : Decode.Decoder ", messageName)
	f.P(decoderName, " =")
	f.P("    Pipeline.decode ", messageName)

	for _, field := range msg.Fields {
		jsonName := field.Desc.JSONName()
		fieldDecoder, err := elmDecoder(field)
		if err != nil {
			g.gen.Error(err)
			return
		}
		f.P("        |> Pipeline.required \"", jsonName, "\" ", fieldDecoder)
	}
	f.P("")
}

func (g *Generator) genEncoder(f *protogen.GeneratedFile, msg *protogen.Message) {
	messageName := msg.GoIdent.GoName
	encoderName := strings.ToLower(messageName[:1]) + messageName[1:] + "Encoder"
	instanceName := strings.ToLower(messageName[:1]) + messageName[1:]

	f.P(encoderName, " : ", messageName, " -> Encode.Value")
	f.P(encoderName, " ", instanceName, " =")
	f.P("    Encode.object")
	f.P("        [ ")

	for i, field := range msg.Fields {
		fieldName := camelCase(string(field.Desc.Name()))
		jsonName := field.Desc.JSONName()
		fieldEncoder, err := elmEncoder(field, instanceName+"."+fieldName)
		if err != nil {
			g.gen.Error(err)
			return
		}

		separator := ","
		if i == len(msg.Fields)-1 {
			separator = ""
		}
		f.P("            (\"", jsonName, "\", ", fieldEncoder, ")", separator)
	}

	f.P("        ]")
	f.P("")
}

func elmType(field *protogen.Field) (string, error) {
	var t string
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		t = "String"
	case protoreflect.Int32Kind, protoreflect.Int64Kind, protoreflect.Sint32Kind, protoreflect.Sint64Kind, protoreflect.Uint32Kind, protoreflect.Uint64Kind, protoreflect.Fixed32Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed32Kind, protoreflect.Sfixed64Kind:
		t = "Int"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		t = "Float"
	case protoreflect.BoolKind:
		t = "Bool"
	case protoreflect.MessageKind:
		t = field.Message.GoIdent.GoName
	default:
		return "", fmt.Errorf("unknown type for field %s: %s", field.Desc.Name(), field.Desc.Kind().String())
	}

	if field.Desc.IsList() {
		return "(List " + t + ")", nil
	}
	return t, nil
}

func elmDecoder(field *protogen.Field) (string, error) {
	var d string
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		d = "Decode.string"
	case protoreflect.Int32Kind, protoreflect.Int64Kind, protoreflect.Sint32Kind, protoreflect.Sint64Kind, protoreflect.Uint32Kind, protoreflect.Uint64Kind, protoreflect.Fixed32Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed32Kind, protoreflect.Sfixed64Kind:
		d = "Decode.int"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		d = "Decode.float"
	case protoreflect.BoolKind:
		d = "Decode.bool"
	case protoreflect.MessageKind:
		messageName := field.Message.GoIdent.GoName
		d = strings.ToLower(messageName[:1]) + messageName[1:] + "Decoder"
	default:
		return "", fmt.Errorf("unknown decoder for field %s: %s", field.Desc.Name(), field.Desc.Kind().String())
	}

	if field.Desc.IsList() {
		return "(Decode.list " + d + ")", nil
	}
	return d, nil
}

func elmEncoder(field *protogen.Field, fieldAccessor string) (string, error) {
	var e string
	switch field.Desc.Kind() {
	case protoreflect.StringKind:
		e = "Encode.string"
	case protoreflect.Int32Kind, protoreflect.Int64Kind, protoreflect.Sint32Kind, protoreflect.Sint64Kind, protoreflect.Uint32Kind, protoreflect.Uint64Kind, protoreflect.Fixed32Kind, protoreflect.Fixed64Kind, protoreflect.Sfixed32Kind, protoreflect.Sfixed64Kind:
		e = "Encode.int"
	case protoreflect.FloatKind, protoreflect.DoubleKind:
		e = "Encode.float"
	case protoreflect.BoolKind:
		e = "Encode.bool"
	case protoreflect.MessageKind:
		messageName := field.Message.GoIdent.GoName
		e = strings.ToLower(messageName[:1]) + messageName[1:] + "Encoder"
	default:
		return "", fmt.Errorf("unknown encoder for field %s: %s", field.Desc.Name(), field.Desc.Kind().String())
	}

	if field.Desc.IsList() {
		// The encoder function for the inner type doesn't take an argument, so we need to handle it slightly differently.
		encoderName := e
		if !strings.HasSuffix(e, "Encoder") {
			// For primitive types, the function name is just the type (e.g., Encode.string)
			// For message types, it's the function name we constructed (e.g., userEncoder)
			encoderName = e
		}
		return "(Encode.list " + encoderName + " " + fieldAccessor + ")", nil
	}
	return e + " " + fieldAccessor, nil
}
