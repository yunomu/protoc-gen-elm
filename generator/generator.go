package generator

import (
	"sort"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

type option func(*Generator)

func WithGolden(golden bool) option {
	return func(g *Generator) {
		g.golden = golden
	}
}

type Generator struct {
	gen    *protogen.Plugin
	golden bool

	hasOptional bool
	hasBytes    bool
}

func New(gen *protogen.Plugin, opts ...option) *Generator {
	g := &Generator{gen: gen}
	for _, opt := range opts {
		opt(g)
	}
	return g
}

// camelCase converts a snake_case string to camelCase.
func camelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := 1; i < len(parts); i++ {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

// upperCamelCase converts a snake_case string to UpperCamelCase.
func upperCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

func (g *Generator) genBytesLib(f *GeneratedFile) {
	f.Libs(`base64error : BDecode.Error -> Decode.Decoder a
base64error err =
    case err of
        BDecode.ValidationError ->
            Decode.fail "base64 validation error"

        BDecode.InvalidByteSequence ->
            Decode.fail "base64 invalid byte sequence"


result : (error -> a) -> (value -> a) -> Result error value -> a
result errf f r =
    case r of
        Ok v ->
            f v

        Err err ->
            errf err


decodeBytes : Decode.Decoder Bytes.Bytes
decodeBytes =
    Decode.string
        |> Decode.andThen
            (BDecode.decode BDecode.bytes >> result base64error Decode.succeed)


encodeBytes : Bytes.Bytes -> Encode.Value
encodeBytes =
    Encode.string << BEncode.encode << BEncode.bytes`)
}

func (g *Generator) genOptionalLib(f *GeneratedFile) {
	f.Libs(`nullable : (a -> Encode.Value) -> Maybe a -> Encode.Value
nullable f =
    Maybe.withDefault Encode.null << Maybe.map f`)
}

type GeneratedFile struct {
	header   [][]any
	module   string
	exposing []string
	imports  []string
	libs     []string
	v        [][]any
}

func (g *GeneratedFile) Header(v ...any) {
	g.header = append(g.header, v)
}

func (g *GeneratedFile) Module(v string) {
	g.module = v
}

func (g *GeneratedFile) Exposing(v string) {
	g.exposing = append(g.exposing, v)
}

func (g *GeneratedFile) Import(v string) {
	g.imports = append(g.imports, v)
}

func (g *GeneratedFile) Libs(v string) {
	g.libs = append(g.libs, v)
}

func (g *GeneratedFile) P(v ...any) {
	g.v = append(g.v, v)
}

func (g *GeneratedFile) Output(f *protogen.GeneratedFile) {
	for _, v := range g.header {
		f.P(v...)
	}
	f.P("")

	f.P("module ", g.module, " exposing")
	sort.Sort(sort.StringSlice(g.exposing))
	sep := "("
	for _, v := range g.exposing {
		f.P("    ", sep, " ", v)
		sep = ","
	}
	f.P("    )")
	f.P("")

	sort.Sort(sort.StringSlice(g.imports))
	for _, v := range g.imports {
		f.P("import ", v)
	}

	if len(g.libs) != 0 {
		for _, v := range g.libs {
			f.P("")
			f.P("")
			f.P(v)
		}
	}

	for _, v := range g.v {
		f.P(v...)
	}
}

func (g *Generator) GenerateFile(file *protogen.File) *protogen.GeneratedFile {
	protoPath := file.Desc.Path()
	path := strings.TrimSuffix(protoPath, ".proto")

	pathParts := strings.Split(path, "/")
	for i, part := range pathParts {
		pathParts[i] = upperCamelCase(part)
	}
	filename := strings.Join(pathParts, "/") + ".elm"
	if g.golden {
		filename += ".golden"
	}

	f := &GeneratedFile{}

	f.Header(`-- DO NOT EDIT
--
-- This file is automatically generated by protoc-gen-elm.`)
	f.Header("-- Source: ", file.Desc.Path())

	moduleName := strings.ReplaceAll(filename, "/", ".")
	moduleName = strings.TrimSuffix(moduleName, ".elm.golden")
	moduleName = strings.TrimSuffix(moduleName, ".elm")

	f.Module(moduleName)

	f.Import("Json.Decode as Decode")
	f.Import("Json.Encode as Encode")

	for _, msg := range file.Messages {
		f.P("")
		f.P("")
		g.genMessage(f, msg)
		f.P("")
		f.P("")
		g.genDecoder(f, msg)
		f.P("")
		f.P("")
		g.genEncoder(f, msg)
	}

	if g.hasBytes {
		f.Import("Bytes")
		f.Import("Base64.Decode as BDecode")
		f.Import("Base64.Encode as BEncode")
		g.genBytesLib(f)
	}

	if g.hasOptional {
		f.Import("Maybe")
		g.genOptionalLib(f)
	}

	genFile := g.gen.NewGeneratedFile(filename, file.GoImportPath)
	f.Output(genFile)

	return genFile
}
