-- DO NOT EDIT
--
-- This file is automatically generated by protoc-gen-elm.
-- Source: test.proto

module Test exposing
    ( User
    , UserList
    , userDecoder
    , userEncoder
    , userListDecoder
    , userListEncoder
    )

import Base64.Decode as BDecode
import Base64.Encode as BEncode
import Bytes
import Json.Decode as Decode
import Json.Encode as Encode
import Maybe


base64error : BDecode.Error -> Decode.Decoder a
base64error err =
    case err of
        BDecode.ValidationError ->
            Decode.fail "base64 validation error"

        BDecode.InvalidByteSequence ->
            Decode.fail "base64 invalid byte sequence"


result : (error -> a) -> (value -> a) -> Result error value -> a
result errf f r =
    case r of
        Ok v ->
            f v

        Err err ->
            errf err


decodeBytes : Decode.Decoder Bytes.Bytes
decodeBytes =
    Decode.string
        |> Decode.andThen
            (BDecode.decode BDecode.bytes >> result base64error Decode.succeed)


encodeBytes : Bytes.Bytes -> Encode.Value
encodeBytes =
    Encode.string << BEncode.encode << BEncode.bytes


nullable : (a -> Encode.Value) -> Maybe a -> Encode.Value
nullable f =
    Maybe.withDefault Encode.null << Maybe.map f


type alias User =
    { userId : String
    , userName : String
    , age : Maybe Int
    , blob : Bytes.Bytes
    }


userDecoder : Decode.Decoder User
userDecoder =
    Decode.map4 User
        (Decode.field "userId" Decode.string)
        (Decode.field "userName" Decode.string)
        (Decode.field "age" <| Decode.maybe Decode.int)
        (Decode.field "blob" decodeBytes)


userEncoder : User -> Encode.Value
userEncoder user =
    Encode.object
        [ ("userId", Encode.string user.userId)
        , ("userName", Encode.string user.userName)
        , ("age", (nullable Encode.int user.age))
        , ("blob", encodeBytes user.blob)
        ]


type alias UserList =
    { users : List User
    }


userListDecoder : Decode.Decoder UserList
userListDecoder =
    Decode.map UserList
        (Decode.field "users" (Decode.list userDecoder))


userListEncoder : UserList -> Encode.Value
userListEncoder userList =
    Encode.object
        [ ("users", (Encode.list userEncoder userList.users))
        ]
